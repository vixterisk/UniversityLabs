Пусть имеется набор из N зависимых заданий. Каждое задание имеет единичную длительность. Зависимость между заданиями образует граф и задается набором зависимостей вида «AB», что означает, что задание B может начать выполняться лишь после того, как было завершено выполнение задания A. Также имеется набор из M универсальных исполнителей. Каждый исполнитель может выполнять любое задание. В каждый момент времени каждый исполнитель может выполнять не более одного задания. Каждое задание может выполняться только одним исполнителем.
Под расписанием понимается указание, какой исполнитель какое задание должен выполнять в каждый момент времени. Задания не прерываются, то есть если какой-либо исполнитель начал выполнение задания A, он должен полностью завершить его выполнение прежде, чем приступить к выполнению другого задания. Временем выполнения расписания называется время, за которое будут выполнены все задания.
Суть задачи: для заданной системы заданий (заданных количества заданий и зависимостей между заданиями) и для заданного числа исполнителей составить расписание с минимальным временем выполнения.
Алгоритм решения состоит из 2 этапов.
1 этап. Определить приоритеты для каждого задания. Приоритет – это целое число от 1 до N. Каждое задание должно получить уникальный приоритет. Чем выше приоритет задания, тем раньше оно должно выполняться.
2 этап. Составить расписание в соответствии с вычисленными приоритетами.
Алгоритм выполнения 1 этапа (вычисление приоритетов). Алгоритм очень похож на алгоритм Демукрона выполнения топологической сортировки, только порядок рассмотрения вершин более детерминирован за счет расстановки специальных меток. Можно сказать, что применение алгоритма Демукрона (или любого другого алгоритма топологической сортировки) позволило бы получить оптимальное расписание для 1 исполнителя, нам же необходимо учитывать наличие M исполнителей.
Обозначим T = {t1, t2, …, tN} – множество заданий. Если существует зависимость вида «A->B», то задание A будем называть предшествующим, а задание B – последующим.
Обозначим UT – множество заданий, которым еще не назначен приоритет, p – текущий приоритет.
1) UT <- T (изначально в UT находятся все задания)
2) Найти множество C – множество заданий из UT, для которых нет последующих заданий. Пусть k – количество заданий в сформированном множестве C.
3) Назначить заданиям из множества C приоритеты от 1 до k в произвольном порядке.
4) UT <- UT \ C (удалить из UT все задания, входящие в C)
5) p <- k + 1 (приоритеты от 1 до k уже назначены, далее расставляем приоритеты с k + 1)
6) Пока множество UT не пусто, выполнять следующие шаги.
6.1) Найти множество C – множество заданий из UT таких, что для всех их последующих заданий приоритет уже известен. Пусть k – количество заданий в сформированном множестве C.
6.2) если k=0, то вывести сообщение об ошибке: указанный набор заданий не может быть выполнен. По сути это означает, что в графе зависимостей имеется ориентированный цикл (например, A->B, B->C, C->A). Очевидно, что циклически зависящие друг от друга задания не могут быть выполнены ни в какой последовательности.
6.3) Для каждого задания из C составить «метку» - список приоритетов всех последующих заданий в порядке убывания.
6.4) Отсортировать задания в C в лексикографическом порядке меток.
6.5) Назначить заданиям из множества C приоритеты от p до (p+k–1) в соответствии с порядком сортировки.
6.6) UT <- UT \ C (удалить из UT все задания, входящие в C)
6.7) p <- p + k
7) Конец алгоритма
На самом деле так явно выделять отдельные итерации с полным перестроением множества C не обязательно, можно это множество пополнять «непрерывно». Немного пересмотрим алгоритм, уточнив детали реализации. Для представления заданий используем структуру, в которой будем хранить следующую информацию:
- Название задания (name)
- Приоритет (priority)
- Список предшествующих заданий (prev)
- Количество предшествующих заданий (prevCnt)
- Список последующих заданий (next)
- Количество последующих заданий (nextCnt)
- Метка задания (mark)
При считывании входных данных заполняются все поля, кроме приоритета. Метка изначально является пустым списком. 
1) Найти список L – список заданий из T, для которых нет последующих заданий (то есть множество таких заданий t, для которых t.nextCnt = 0). В списке L должна поддерживаться упорядоченность заданий в лексикографическом порядке их меток. На данном шаге порядок включения заданий в список L не имеет значения, поскольку метки всех заданий являются пустыми.
2) p <- 1;
3) Пока список L не пуст, выполнять следующие шаги.
3.1) Взять из списка первое задание t (удалив его из списка)
3.2) t.priority <- p
3.3) Для каждого задания tp из списка t.prev:
3.3.1) добавить число p в начало «метки» tp.mark (тем самым гарантируется, что в метке все приоритеты будут расположены по убыванию)
3.3.2) tp.nextCnt <- tp.nextCnt – 1
3.3.3) если tp.nextCnt стало равно 0 (то есть у задания tp стали известны приоритеты всех последующих заданий), то добавить задание tp в список L с учетом лексикографического порядка меток. Учитывая, что в метку задания tp только что было добавлено наибольшее на данный момент число p, позицию для вставки лучше искать начиная с конца списка L (однако заметим, что работа tp не всегда будет добавляться в самый конец списка L)
3.4) p <- p + 1
4) Выполнить проверку, что всем заданиям назначен приоритет. Если есть задания, которым приоритет не назначен, то вывести сообщение об ошибке: указанный набор заданий не может быть выполнен.
5) Конец алгоритма.

Алгоритм выполнения 2 этапа. По результатам выполнения 1 этапа у каждого задания задан приоритет.
1) Отсортируем список всех заданий T в порядке убывания приоритета (вместо этого можно было просто на 1 этапе вместо присваивания приоритетов на шаге 3.2 формировать новый список)
2) Сформировать список L – список заданий из T, для которых нет предшествующих заданий (то есть множество таких заданий t, для которых t.prevCnt = 0). В списке L должна поддерживаться упорядоченность заданий по убыванию приоритета (то есть порядок должен быть такой же, как в списке T).
3) step <- 1
4) Пока список L не пуст, выполнять следующие шаги.
4.1) Выбрать из списка L первые M заданий (если в L имеется менее M заданий, то выбрать все). Пусть выбрано k заданий (k <= M). Назначить выбранные задания исполнителям (если k=M, то всем исполнителям, если k<M, то любым k из них) на период времени step. Для каждого задания t из числа выбранных:
4.1.1) удалить t из L
4.1.2) для каждого задания tl из списка t.next:
4.1.2.1) tl.prevCnt <- tl.prevCnt – 1
4.1.2.2) если tl.prevCnt стало равно 0 (то есть у задания tl больше нет предшествующих, и в следующий период времени его можно будет выполнить), то добавить tl в список L с учетом его приоритета
4.2) step <- step + 1
5) Конец алгоритма
Здесь важно обратить внимание на то, что на шаге 4.1 вначале полностью формируется список из первых k (k<=M) заданий, и только потом в L начинают добавляться новые задания (на шаге 4.1.2.2). Если формировать такой список «непрерывно», это может нарушить требование зависимости работ, так как мы начнем выполнять работу в тот же момент времени, в который выполняется предшествующая ей.

В заключении отметим, что описанный алгоритм гарантирует построение оптимального расписания только для числа исполнителей M = 1 и M = 2. Для M >= 3 алгоритм является приближенным и не гарантирует построение самого оптимального расписания.
